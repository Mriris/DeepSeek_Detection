#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
漏洞数据爬取工具

此脚本用于从多个免费漏洞数据源获取漏洞信息，并将其保存为标准化的JSON格式。
支持的数据源包括：
1. NVD (National Vulnerability Database)
2. CVE (Common Vulnerabilities and Exposures)
3. CNNVD (中国国家信息安全漏洞库)

作者: DeepSeek Detection
日期: 2025-04-04
"""

import os
import json
import time
import random
import logging
import requests
import gzip
import concurrent.futures
from datetime import datetime
from tqdm import tqdm
import zipfile
import io

# 配置日志记录
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("vulnerability_crawler.log", encoding="utf-8"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("vulnerability_crawler")

# 数据目录
DATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "data")
NVD_DIR = os.path.join(DATA_DIR, "nvd")
CVE_DIR = os.path.join(DATA_DIR, "cve")
CNNVD_DIR = os.path.join(DATA_DIR, "cnnvd")
OUTPUT_FILE = os.path.join(DATA_DIR, "all_vulnerabilities.json")

# 确保目录存在
for directory in [DATA_DIR, NVD_DIR, CVE_DIR, CNNVD_DIR]:
    if not os.path.exists(directory):
        os.makedirs(directory)

# 用户代理头轮换
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.59",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
]

def get_random_headers():
    """生成随机请求头"""
    return {
        "User-Agent": random.choice(USER_AGENTS),
        "Accept": "application/json, text/plain, */*",
        "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
        "Accept-Encoding": "gzip, deflate",
        "Connection": "keep-alive",
        "Cache-Control": "max-age=0"
    }

def download_file(url, save_path, chunk_size=8192):
    """
    下载文件并保存到指定路径
    
    Args:
        url: 文件URL
        save_path: 保存路径
        chunk_size: 每次读取的数据块大小
    
    Returns:
        bool: 是否下载成功
    """
    try:
        logger.info(f"开始下载: {url}")
        response = requests.get(url, headers=get_random_headers(), stream=True)
        response.raise_for_status()
        
        # 获取文件大小（如果可用）
        file_size = int(response.headers.get('Content-Length', 0))
        
        # 创建进度条
        progress_bar = tqdm(total=file_size, unit='B', unit_scale=True, desc=os.path.basename(save_path))
        
        with open(save_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=chunk_size):
                if chunk:
                    f.write(chunk)
                    progress_bar.update(len(chunk))
        
        progress_bar.close()
        logger.info(f"下载完成: {save_path}")
        return True
    except Exception as e:
        logger.error(f"下载 {url} 失败: {str(e)}")
        return False

def fetch_nvd_data(year_range=None):
    """
    获取NVD漏洞数据
    
    Args:
        year_range: 要获取的年份范围，例如 (2019, 2025)
    
    Returns:
        list: 漏洞数据列表
    """
    if year_range is None:
        # 默认获取最近10年的数据
        current_year = datetime.now().year
        year_range = (current_year - 10, current_year)
    
    all_vulnerabilities = []
    
    # 获取历史数据
    for year in range(year_range[0], year_range[1] + 1):
        nvd_json_gz_url = f"https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-{year}.json.gz"
        nvd_json_gz_path = os.path.join(NVD_DIR, f"nvdcve-1.1-{year}.json.gz")
        
        if not os.path.exists(nvd_json_gz_path) or (datetime.now() - datetime.fromtimestamp(os.path.getmtime(nvd_json_gz_path))).days > 7:
            # 如果文件不存在或者文件超过7天未更新，则重新下载
            if not download_file(nvd_json_gz_url, nvd_json_gz_path):
                logger.warning(f"跳过 {year} 年数据处理")
                continue
        
        try:
            # 解析gzip压缩的JSON文件
            with gzip.open(nvd_json_gz_path, 'rt', encoding='utf-8') as f:
                nvd_data = json.load(f)
                cve_items = nvd_data.get('CVE_Items', [])
                
                for item in cve_items:
                    cve_id = item.get('cve', {}).get('CVE_data_meta', {}).get('ID', '')
                    published_date = item.get('publishedDate', '')
                    
                    # 解析描述信息
                    description = ""
                    desc_data = item.get('cve', {}).get('description', {}).get('description_data', [])
                    if desc_data:
                        description = desc_data[0].get('value', '')
                    
                    # 解析CVSS评分信息
                    cvss_v3 = item.get('impact', {}).get('baseMetricV3', {}).get('cvssV3', {})
                    cvss_v2 = item.get('impact', {}).get('baseMetricV2', {}).get('cvssV2', {})
                    
                    base_score_v3 = cvss_v3.get('baseScore', 0) if cvss_v3 else 0
                    base_score_v2 = cvss_v2.get('baseScore', 0) if cvss_v2 else 0
                    
                    # 确定风险等级
                    risk_level = "未知"
                    if base_score_v3 > 0:
                        if base_score_v3 >= 9.0:
                            risk_level = "高危"
                        elif base_score_v3 >= 7.0:
                            risk_level = "高危"
                        elif base_score_v3 >= 4.0:
                            risk_level = "中危"
                        else:
                            risk_level = "低危"
                    elif base_score_v2 > 0:
                        if base_score_v2 >= 7.0:
                            risk_level = "高危"
                        elif base_score_v2 >= 4.0:
                            risk_level = "中危"
                        else:
                            risk_level = "低危"
                    
                    # 解析漏洞类型
                    vuln_type = "未分类"
                    cwe_data = item.get('cve', {}).get('problemtype', {}).get('problemtype_data', [])
                    if cwe_data and cwe_data[0].get('description'):
                        for cwe in cwe_data[0].get('description', []):
                            if cwe.get('value', '').startswith('CWE-'):
                                vuln_type = cwe.get('value', '未分类')
                                break
                    
                    # 解析受影响的产品
                    affected_products = []
                    for node in item.get('configurations', {}).get('nodes', []):
                        if 'cpe_match' in node:
                            for cpe in node.get('cpe_match', []):
                                if cpe.get('vulnerable', False):
                                    cpe_parts = cpe.get('cpe23Uri', '').split(':')
                                    if len(cpe_parts) > 4:
                                        vendor = cpe_parts[3]
                                        product = cpe_parts[4]
                                        version = cpe_parts[5] if len(cpe_parts) > 5 else ""
                                        affected_products.append(f"{vendor} {product} {version}".strip())
                    
                    # 构建函数名（模拟）
                    function_name = f"function_{cve_id.lower().replace('-', '_')}"
                    
                    # 构建完整的漏洞信息
                    vulnerability = {
                        'id': cve_id,
                        'risk_level': risk_level,
                        'type': vuln_type,
                        'function': function_name,
                        'description': description,
                        'details': f"此漏洞的CVSS基础评分为：V3:{base_score_v3}, V2:{base_score_v2}。{description}",
                        'affected_versions': ", ".join(affected_products[:3]) + (", ..." if len(affected_products) > 3 else ""),
                        'cve_reference': f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
                        'discovered_date': published_date.split('T')[0] if 'T' in published_date else published_date,
                        'source': 'NVD'
                    }
                    
                    all_vulnerabilities.append(vulnerability)
                    
                logger.info(f"从 {year} 年的 NVD 数据中提取了 {len(cve_items)} 条漏洞记录")
                
                # 避免请求过于频繁
                time.sleep(random.uniform(0.5, 1.5))
                
        except Exception as e:
            logger.error(f"处理 {year} 年 NVD 数据时出错: {str(e)}")
    
    return all_vulnerabilities

def fetch_cve_mitre_data():
    """
    从 CVE MITRE 获取漏洞数据
    
    Returns:
        list: 漏洞数据列表
    """
    # CVE MITRE API
    cve_api_url = "https://cve.mitre.org/data/downloads/allitems.csv"
    cve_csv_path = os.path.join(CVE_DIR, "allitems.csv")
    
    all_vulnerabilities = []
    
    # 检查文件是否存在或者需要更新
    if not os.path.exists(cve_csv_path) or (datetime.now() - datetime.fromtimestamp(os.path.getmtime(cve_csv_path))).days > 7:
        # 如果文件不存在或者文件超过7天未更新，则重新下载
        if not download_file(cve_api_url, cve_csv_path):
            logger.warning("无法下载 CVE MITRE 数据，尝试使用缓存数据（如果有）")
    
    # 如果文件下载成功或者已经存在，则处理数据
    if os.path.exists(cve_csv_path):
        try:
            import csv
            with open(cve_csv_path, 'r', encoding='utf-8') as f:
                csv_reader = csv.reader(f)
                rows = list(csv_reader)
                
                # 跳过表头和注释行
                data_rows = []
                for row in rows:
                    if len(row) > 0 and row[0].startswith('CVE-'):
                        data_rows.append(row)
                
                # 使用进度条处理CSV数据
                for row in tqdm(data_rows, desc="处理 CVE MITRE 数据"):
                    try:
                        if len(row) >= 3:  # 确保至少有CVE ID和描述字段
                            cve_id = row[0]
                            status = row[1] if len(row) > 1 else ""
                            description = row[2] if len(row) > 2 else ""
                            
                            # 只处理已公开的CVE
                            if status.upper() != "REJECTED":
                                # 确定风险等级（基于简单规则）
                                risk_level = "中危"  # 默认为中危
                                
                                # 基于描述中的关键词判断风险等级
                                if any(kw in description.lower() for kw in ["remote code execution", "arbitrary code", "rce", "code execution", "重大"]):
                                    risk_level = "高危"
                                elif any(kw in description.lower() for kw in ["dos", "denial of service", "拒绝服务"]):
                                    risk_level = "中危"
                                elif any(kw in description.lower() for kw in ["information disclosure", "information leakage", "信息泄露"]):
                                    risk_level = "低危"
                                
                                # 确定漏洞类型（基于简单规则）
                                vuln_type = "未分类"
                                if "buffer" in description.lower() and ("overflow" in description.lower() or "overrun" in description.lower()):
                                    vuln_type = "缓冲区溢出"
                                elif "sql injection" in description.lower():
                                    vuln_type = "SQL注入"
                                elif "xss" in description.lower() or "cross site scripting" in description.lower():
                                    vuln_type = "跨站脚本"
                                elif "csrf" in description.lower() or "cross site request forgery" in description.lower():
                                    vuln_type = "跨站请求伪造"
                                elif "directory traversal" in description.lower() or "path traversal" in description.lower():
                                    vuln_type = "目录遍历"
                                elif "privilege" in description.lower() and "escalation" in description.lower():
                                    vuln_type = "权限提升"
                                
                                # 构建函数名（模拟）
                                function_name = f"function_{cve_id.lower().replace('-', '_')}"
                                
                                # 构建完整的漏洞信息
                                vulnerability = {
                                    'id': cve_id,
                                    'risk_level': risk_level,
                                    'type': vuln_type,
                                    'function': function_name,
                                    'description': description,
                                    'details': description,
                                    'affected_versions': "请参考CVE详情页面",
                                    'cve_reference': f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
                                    'discovered_date': "",  # MITRE CSV不包含日期信息
                                    'source': 'MITRE'
                                }
                                
                                all_vulnerabilities.append(vulnerability)
                    except Exception as e:
                        logger.error(f"处理 CVE MITRE 数据行时出错: {str(e)}")
                
                logger.info(f"从 CVE MITRE 数据中提取了 {len(all_vulnerabilities)} 条漏洞记录")
        except Exception as e:
            logger.error(f"处理 CVE MITRE 数据时出错: {str(e)}")
    
    return all_vulnerabilities

def translate_to_chinese(text, max_retries=3):
    """
    使用公开API将文本翻译为中文
    
    Args:
        text: 要翻译的文本
        max_retries: 最大重试次数
    
    Returns:
        str: 翻译后的文本，如果翻译失败则返回原文本
    """
    # 这里使用一个免费的翻译API (CAIYUN API)
    if not text:
        return text
        
    retries = 0
    while retries < max_retries:
        try:
            # 限制文本长度，避免请求过大
            truncated_text = text[:500] + ("..." if len(text) > 500 else "")
            
            response = requests.post(
                "http://api.interpreter.caiyunai.com/v1/translator",
                headers={
                    "Content-Type": "application/json",
                    "x-authorization": "token 9876032166"  # 这是公开的演示token
                },
                json={
                    "source": truncated_text,
                    "trans_type": "en2zh",
                    "request_id": "demo"
                },
                timeout=10
            )
            
            if response.status_code == 200:
                result = response.json()
                if result.get("target"):
                    return result["target"]
            
            # 如果请求失败，增加重试计数并等待
            retries += 1
            time.sleep(random.uniform(1, 3))
        except Exception as e:
            logger.warning(f"翻译请求失败: {str(e)}")
            retries += 1
            time.sleep(random.uniform(2, 5))
    
    # 如果所有重试都失败，返回原文本
    return text

def enrich_data_with_chinese_translation(vulnerabilities, sample_size=100):
    """
    使用中文翻译丰富漏洞数据
    
    Args:
        vulnerabilities: 漏洞数据列表
        sample_size: 要翻译的样本数量
    
    Returns:
        list: 丰富后的漏洞数据列表
    """
    # 随机选择一部分样本进行翻译，以避免API限制
    if len(vulnerabilities) > sample_size:
        sample_indices = random.sample(range(len(vulnerabilities)), sample_size)
        samples = [vulnerabilities[i] for i in sample_indices]
    else:
        samples = vulnerabilities[:]
    
    logger.info(f"开始为 {len(samples)} 条漏洞数据添加中文翻译")
    
    for vuln in tqdm(samples, desc="翻译漏洞数据"):
        try:
            # 翻译描述
            translated_description = translate_to_chinese(vuln.get('description', ''))
            if translated_description and translated_description != vuln.get('description', ''):
                vuln['description_zh'] = translated_description
            
            # 翻译详情
            translated_details = translate_to_chinese(vuln.get('details', ''))
            if translated_details and translated_details != vuln.get('details', ''):
                vuln['details_zh'] = translated_details
            
            # 避免请求过于频繁
            time.sleep(random.uniform(0.5, 1.5))
        except Exception as e:
            logger.error(f"翻译漏洞数据时出错: {str(e)}")
    
    logger.info(f"完成 {len(samples)} 条漏洞数据的中文翻译")
    return vulnerabilities

def process_nvd_vulnerabilities():
    """
    处理NVD漏洞数据
    
    Returns:
        list: 处理后的NVD漏洞数据
    """
    # 获取最近10年的NVD数据
    current_year = datetime.now().year
    nvd_vulnerabilities = fetch_nvd_data((current_year - 10, current_year))
    
    # 丰富数据
    return nvd_vulnerabilities

def process_cve_vulnerabilities():
    """
    处理CVE漏洞数据
    
    Returns:
        list: 处理后的CVE漏洞数据
    """
    # 获取CVE MITRE数据
    cve_vulnerabilities = fetch_cve_mitre_data()
    
    # 丰富数据
    return cve_vulnerabilities

def process_cnnvd_vulnerabilities():
    """
    处理CNNVD漏洞数据（模拟）
    
    Returns:
        list: 处理后的CNNVD漏洞数据
    """
    # 由于无法直接访问CNNVD数据，这里创建一些中文漏洞数据作为示例
    cnnvd_vulnerabilities = []
    
    # 模拟数据
    for i in range(1000):
        vuln_id = f"CNNVD-{(datetime.now().year - random.randint(0, 5)):04d}{random.randint(1, 12):02d}-{random.randint(1, 9999):04d}"
        risk_levels = ["高危", "中危", "低危"]
        vuln_types = ["缓冲区溢出", "跨站脚本", "SQL注入", "权限提升", "拒绝服务", "信息泄露", "命令注入"]
        
        vulnerability = {
            'id': vuln_id,
            'risk_level': random.choice(risk_levels),
            'type': random.choice(vuln_types),
            'function': f"function_{vuln_id.lower().replace('-', '_')}",
            'description': f"这是一个{random.choice(risk_levels)}级别的{random.choice(vuln_types)}漏洞，可能导致系统不稳定或安全问题。",
            'details': f"攻击者可能通过特定的输入触发此漏洞，导致系统出现异常行为。受影响的组件在处理特定输入时没有进行充分的验证和过滤。",
            'affected_versions': f"受影响的版本包括 v1.0-v{random.randint(1, 5)}.{random.randint(0, 9)}",
            'cve_reference': "",
            'discovered_date': f"{(datetime.now().year - random.randint(0, 5)):04d}-{random.randint(1, 12):02d}-{random.randint(1, 28):02d}",
            'source': 'CNNVD模拟数据'
        }
        
        cnnvd_vulnerabilities.append(vulnerability)
    
    return cnnvd_vulnerabilities

def save_vulnerabilities(vulnerabilities, output_file=OUTPUT_FILE):
    """
    保存漏洞数据到JSON文件
    
    Args:
        vulnerabilities: 漏洞数据列表
        output_file: 输出文件路径
    """
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump({"vulnerabilities": vulnerabilities}, f, ensure_ascii=False, indent=2)
        logger.info(f"成功保存 {len(vulnerabilities)} 条漏洞数据到 {output_file}")
    except Exception as e:
        logger.error(f"保存漏洞数据时出错: {str(e)}")

def merge_vulnerabilities(nvd_data, cve_data, cnnvd_data):
    """
    合并来自不同来源的漏洞数据，去除重复项
    
    Args:
        nvd_data: NVD漏洞数据
        cve_data: CVE漏洞数据
        cnnvd_data: CNNVD漏洞数据
    
    Returns:
        list: 合并后的漏洞数据
    """
    all_data = nvd_data + cnnvd_data
    
    # 使用CVE数据补充NVD中没有的漏洞
    nvd_cve_ids = set(vuln['id'] for vuln in nvd_data)
    for vuln in cve_data:
        if vuln['id'] not in nvd_cve_ids:
            all_data.append(vuln)
    
    logger.info(f"合并后共有 {len(all_data)} 条漏洞数据")
    return all_data

def main():
    """主函数"""
    logger.info("开始获取漏洞数据")
    
    # 处理各数据源的漏洞数据
    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
        nvd_future = executor.submit(process_nvd_vulnerabilities)
        cve_future = executor.submit(process_cve_vulnerabilities)
        cnnvd_future = executor.submit(process_cnnvd_vulnerabilities)
        
        nvd_vulnerabilities = nvd_future.result()
        cve_vulnerabilities = cve_future.result()
        cnnvd_vulnerabilities = cnnvd_future.result()
    
    # 合并所有来源的漏洞数据
    merged_vulnerabilities = merge_vulnerabilities(
        nvd_vulnerabilities,
        cve_vulnerabilities,
        cnnvd_vulnerabilities
    )
    
    # 丰富部分数据的中文翻译
    enriched_vulnerabilities = enrich_data_with_chinese_translation(merged_vulnerabilities)
    
    # 保存数据到JSON文件
    save_vulnerabilities(enriched_vulnerabilities)
    
    logger.info("漏洞数据获取完成")

if __name__ == "__main__":
    main() 