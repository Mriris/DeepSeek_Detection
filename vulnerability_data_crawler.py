#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
漏洞数据爬取工具

此脚本用于从多个免费漏洞数据源获取漏洞信息，并将其保存为标准化的JSON格式。
支持的数据源包括：
1. NVD (National Vulnerability Database)
2. CVE (Common Vulnerabilities and Exposures)
3. CNNVD (中国国家信息安全漏洞库)

作者: DeepSeek Detection
日期: 2025-04-04
"""

import os
import json
import time
import random
import logging
import requests
import gzip
import concurrent.futures
from datetime import datetime
from tqdm import tqdm
import zipfile
import io
import pickle
from concurrent.futures import ThreadPoolExecutor
from functools import lru_cache

# 配置日志记录
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("vulnerability_crawler.log", encoding="utf-8"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("vulnerability_crawler")

# 数据目录
DATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "data")
NVD_DIR = os.path.join(DATA_DIR, "nvd")
CVE_DIR = os.path.join(DATA_DIR, "cve")
CNNVD_DIR = os.path.join(DATA_DIR, "cnnvd")
OUTPUT_FILE = os.path.join(DATA_DIR, "all_vulnerabilities.json")

# 确保目录存在
for directory in [DATA_DIR, NVD_DIR, CVE_DIR, CNNVD_DIR]:
    if not os.path.exists(directory):
        os.makedirs(directory)

# 用户代理头轮换
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.59",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
]

def get_random_headers():
    """生成随机请求头"""
    return {
        "User-Agent": random.choice(USER_AGENTS),
        "Accept": "application/json, text/plain, */*",
        "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
        "Accept-Encoding": "gzip, deflate",
        "Connection": "keep-alive",
        "Cache-Control": "max-age=0"
    }

def download_file(url, save_path, chunk_size=8192):
    """
    下载文件并保存到指定路径
    
    Args:
        url: 文件URL
        save_path: 保存路径
        chunk_size: 每次读取的数据块大小
    
    Returns:
        bool: 是否下载成功
    """
    try:
        logger.info(f"开始下载: {url}")
        response = requests.get(url, headers=get_random_headers(), stream=True)
        response.raise_for_status()
        
        # 获取文件大小（如果可用）
        file_size = int(response.headers.get('Content-Length', 0))
        
        # 创建进度条
        progress_bar = tqdm(total=file_size, unit='B', unit_scale=True, desc=os.path.basename(save_path))
        
        with open(save_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=chunk_size):
                if chunk:
                    f.write(chunk)
                    progress_bar.update(len(chunk))
        
        progress_bar.close()
        logger.info(f"下载完成: {save_path}")
        return True
    except Exception as e:
        logger.error(f"下载 {url} 失败: {str(e)}")
        return False

def fetch_nvd_data(year_range=None):
    """
    获取NVD漏洞数据
    
    Args:
        year_range: 要获取的年份范围，例如 (2019, 2025)
    
    Returns:
        list: 漏洞数据列表
    """
    if year_range is None:
        # 默认获取最近10年的数据
        current_year = datetime.now().year
        year_range = (current_year - 10, current_year)
    
    all_vulnerabilities = []
    
    # 获取历史数据
    for year in range(year_range[0], year_range[1] + 1):
        nvd_json_gz_url = f"https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-{year}.json.gz"
        nvd_json_gz_path = os.path.join(NVD_DIR, f"nvdcve-1.1-{year}.json.gz")
        
        if not os.path.exists(nvd_json_gz_path) or (datetime.now() - datetime.fromtimestamp(os.path.getmtime(nvd_json_gz_path))).days > 7:
            # 如果文件不存在或者文件超过7天未更新，则重新下载
            if not download_file(nvd_json_gz_url, nvd_json_gz_path):
                logger.warning(f"跳过 {year} 年数据处理")
                continue
        
        try:
            # 解析gzip压缩的JSON文件
            with gzip.open(nvd_json_gz_path, 'rt', encoding='utf-8') as f:
                nvd_data = json.load(f)
                cve_items = nvd_data.get('CVE_Items', [])
                
                for item in cve_items:
                    cve_id = item.get('cve', {}).get('CVE_data_meta', {}).get('ID', '')
                    published_date = item.get('publishedDate', '')
                    
                    # 解析描述信息
                    description = ""
                    desc_data = item.get('cve', {}).get('description', {}).get('description_data', [])
                    if desc_data:
                        description = desc_data[0].get('value', '')
                    
                    # 解析CVSS评分信息
                    cvss_v3 = item.get('impact', {}).get('baseMetricV3', {}).get('cvssV3', {})
                    cvss_v2 = item.get('impact', {}).get('baseMetricV2', {}).get('cvssV2', {})
                    
                    base_score_v3 = cvss_v3.get('baseScore', 0) if cvss_v3 else 0
                    base_score_v2 = cvss_v2.get('baseScore', 0) if cvss_v2 else 0
                    
                    # 确定风险等级
                    risk_level = "未知"
                    if base_score_v3 > 0:
                        if base_score_v3 >= 9.0:
                            risk_level = "高危"
                        elif base_score_v3 >= 7.0:
                            risk_level = "高危"
                        elif base_score_v3 >= 4.0:
                            risk_level = "中危"
                        else:
                            risk_level = "低危"
                    elif base_score_v2 > 0:
                        if base_score_v2 >= 7.0:
                            risk_level = "高危"
                        elif base_score_v2 >= 4.0:
                            risk_level = "中危"
                        else:
                            risk_level = "低危"
                    
                    # 解析漏洞类型
                    vuln_type = "未分类"
                    cwe_data = item.get('cve', {}).get('problemtype', {}).get('problemtype_data', [])
                    if cwe_data and cwe_data[0].get('description'):
                        for cwe in cwe_data[0].get('description', []):
                            if cwe.get('value', '').startswith('CWE-'):
                                vuln_type = cwe.get('value', '未分类')
                                break
                    
                    # 解析受影响的产品
                    affected_products = []
                    for node in item.get('configurations', {}).get('nodes', []):
                        if 'cpe_match' in node:
                            for cpe in node.get('cpe_match', []):
                                if cpe.get('vulnerable', False):
                                    cpe_parts = cpe.get('cpe23Uri', '').split(':')
                                    if len(cpe_parts) > 4:
                                        vendor = cpe_parts[3]
                                        product = cpe_parts[4]
                                        version = cpe_parts[5] if len(cpe_parts) > 5 else ""
                                        affected_products.append(f"{vendor} {product} {version}".strip())
                    
                    # 构建函数名（模拟）
                    function_name = f"function_{cve_id.lower().replace('-', '_')}"
                    
                    # 构建完整的漏洞信息
                    vulnerability = {
                        'id': cve_id,
                        'risk_level': risk_level,
                        'type': vuln_type,
                        'function': function_name,
                        'description': description,
                        'details': f"此漏洞的CVSS基础评分为：V3:{base_score_v3}, V2:{base_score_v2}。{description}",
                        'affected_versions': ", ".join(affected_products[:3]) + (", ..." if len(affected_products) > 3 else ""),
                        'cve_reference': f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
                        'discovered_date': published_date.split('T')[0] if 'T' in published_date else published_date,
                        'source': 'NVD'
                    }
                    
                    all_vulnerabilities.append(vulnerability)
                    
                logger.info(f"从 {year} 年的 NVD 数据中提取了 {len(cve_items)} 条漏洞记录")
                
                # 避免请求过于频繁
                time.sleep(random.uniform(0.5, 1.5))
                
        except Exception as e:
            logger.error(f"处理 {year} 年 NVD 数据时出错: {str(e)}")
    
    return all_vulnerabilities

def fetch_cve_mitre_data():
    """
    从 CVE MITRE 获取漏洞数据
    
    Returns:
        list: 漏洞数据列表
    """
    # CVE MITRE API
    cve_api_url = "https://cve.mitre.org/data/downloads/allitems.csv"
    cve_csv_path = os.path.join(CVE_DIR, "allitems.csv")
    
    all_vulnerabilities = []
    
    # 检查文件是否存在或者需要更新
    if not os.path.exists(cve_csv_path) or (datetime.now() - datetime.fromtimestamp(os.path.getmtime(cve_csv_path))).days > 7:
        # 如果文件不存在或者文件超过7天未更新，则重新下载
        if not download_file(cve_api_url, cve_csv_path):
            logger.warning("无法下载 CVE MITRE 数据，尝试使用缓存数据（如果有）")
    
    # 如果文件下载成功或者已经存在，则处理数据
    if os.path.exists(cve_csv_path):
        try:
            import csv
            with open(cve_csv_path, 'r', encoding='latin-1') as f:
                csv_reader = csv.reader(f)
                rows = list(csv_reader)
                
                # 跳过表头和注释行
                data_rows = []
                for row in rows:
                    if len(row) > 0 and row[0].startswith('CVE-'):
                        data_rows.append(row)
                
                # 使用进度条处理CSV数据
                for row in tqdm(data_rows, desc="处理 CVE MITRE 数据"):
                    try:
                        if len(row) >= 3:  # 确保至少有CVE ID和描述字段
                            cve_id = row[0]
                            status = row[1] if len(row) > 1 else ""
                            description = row[2] if len(row) > 2 else ""
                            
                            # 只处理已公开的CVE
                            if status.upper() != "REJECTED":
                                # 确定风险等级（基于简单规则）
                                risk_level = "中危"  # 默认为中危
                                
                                # 基于描述中的关键词判断风险等级
                                if any(kw in description.lower() for kw in ["remote code execution", "arbitrary code", "rce", "code execution", "重大"]):
                                    risk_level = "高危"
                                elif any(kw in description.lower() for kw in ["dos", "denial of service", "拒绝服务"]):
                                    risk_level = "中危"
                                elif any(kw in description.lower() for kw in ["information disclosure", "information leakage", "信息泄露"]):
                                    risk_level = "低危"
                                
                                # 确定漏洞类型（基于简单规则）
                                vuln_type = "未分类"
                                if "buffer" in description.lower() and ("overflow" in description.lower() or "overrun" in description.lower()):
                                    vuln_type = "缓冲区溢出"
                                elif "sql injection" in description.lower():
                                    vuln_type = "SQL注入"
                                elif "xss" in description.lower() or "cross site scripting" in description.lower():
                                    vuln_type = "跨站脚本"
                                elif "csrf" in description.lower() or "cross site request forgery" in description.lower():
                                    vuln_type = "跨站请求伪造"
                                elif "directory traversal" in description.lower() or "path traversal" in description.lower():
                                    vuln_type = "目录遍历"
                                elif "privilege" in description.lower() and "escalation" in description.lower():
                                    vuln_type = "权限提升"
                                
                                # 构建函数名（模拟）
                                function_name = f"function_{cve_id.lower().replace('-', '_')}"
                                
                                # 构建完整的漏洞信息
                                vulnerability = {
                                    'id': cve_id,
                                    'risk_level': risk_level,
                                    'type': vuln_type,
                                    'function': function_name,
                                    'description': description,
                                    'details': description,
                                    'affected_versions': "请参考CVE详情页面",
                                    'cve_reference': f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
                                    'discovered_date': "",  # MITRE CSV不包含日期信息
                                    'source': 'MITRE'
                                }
                                
                                all_vulnerabilities.append(vulnerability)
                    except Exception as e:
                        logger.error(f"处理 CVE MITRE 数据行时出错: {str(e)}")
                
                logger.info(f"从 CVE MITRE 数据中提取了 {len(all_vulnerabilities)} 条漏洞记录")
        except Exception as e:
            logger.error(f"处理 CVE MITRE 数据时出错: {str(e)}")
    
    return all_vulnerabilities

def translate_to_chinese(text, max_retries=3):
    """
    使用更高效的方法在本地将文本翻译为中文
    
    Args:
        text: 要翻译的文本
        max_retries: 最大重试次数
    
    Returns:
        str: 翻译后的文本，如果翻译失败则返回原文本
    """
    if not text:
        return text
    
    try:
        # 尝试使用更快的transformers库进行翻译
        try:
            from transformers import MarianMTModel, MarianTokenizer
            
            # 使用@lru_cache装饰的内部函数确保模型只被加载一次
            @lru_cache(maxsize=1)
            def get_translator():
                model_name = "Helsinki-NLP/opus-mt-en-zh"
                tokenizer = MarianTokenizer.from_pretrained(model_name)
                model = MarianMTModel.from_pretrained(model_name)
                return tokenizer, model
            
            # 获取翻译器
            tokenizer, model = get_translator()
            
            # 限制文本长度以避免内存问题
            max_length = 512
            if len(text) > max_length:
                # 截断文本
                text = text[:max_length]
            
            # 翻译文本
            batch = tokenizer([text], return_tensors="pt", padding=True, truncation=True, max_length=max_length)
            gen = model.generate(**batch)
            translated = tokenizer.batch_decode(gen, skip_special_tokens=True)[0]
            return translated
            
        except (ImportError, ModuleNotFoundError):
            # 如果没有transformers，回退到translate库
            from translate import Translator
            translator = Translator(from_lang="en", to_lang="zh")
            
            # 如果文本太长，分段翻译但不等待
            if len(text) > 500:
                # 按句号分割文本
                segments = text.split('.')
                translated_segments = []
                
                for segment in segments:
                    if segment.strip():
                        # 翻译每个片段
                        translated = translator.translate(segment.strip())
                        translated_segments.append(translated)
                
                # 合并翻译结果
                return '。'.join(translated_segments)
            else:
                # 直接翻译短文本
                return translator.translate(text)
    except Exception as e:
        logger.warning(f"翻译请求失败: {str(e)}")
        return text

# 增加翻译缓存功能
class TranslationCache:
    """翻译缓存类，用于存储和读取翻译结果"""
    
    def __init__(self, cache_file="translation_cache.pkl"):
        self.cache_file = os.path.join(DATA_DIR, cache_file)
        self.cache = {}
        self.load_cache()
    
    def load_cache(self):
        """从文件加载缓存"""
        if os.path.exists(self.cache_file):
            try:
                with open(self.cache_file, 'rb') as f:
                    self.cache = pickle.load(f)
                logger.info(f"已加载 {len(self.cache)} 条翻译缓存")
            except Exception as e:
                logger.warning(f"加载翻译缓存失败: {str(e)}")
                self.cache = {}
    
    def save_cache(self):
        """保存缓存到文件"""
        try:
            with open(self.cache_file, 'wb') as f:
                pickle.dump(self.cache, f)
            logger.info(f"已保存 {len(self.cache)} 条翻译缓存")
        except Exception as e:
            logger.warning(f"保存翻译缓存失败: {str(e)}")
    
    def get(self, text):
        """获取缓存的翻译结果"""
        return self.cache.get(text)
    
    def put(self, text, translation):
        """添加翻译结果到缓存"""
        self.cache[text] = translation
        # 每增加100条翻译结果保存一次
        if len(self.cache) % 100 == 0:
            self.save_cache()

# 创建翻译缓存实例
translation_cache = TranslationCache()

# 使用缓存的翻译函数
def cached_translate(text):
    """使用缓存机制的翻译函数"""
    if not text:
        return text
    
    # 检查缓存
    cached_result = translation_cache.get(text)
    if cached_result:
        return cached_result
    
    # 没有缓存结果，执行翻译
    result = translate_to_chinese(text)
    
    # 存入缓存
    if result != text:  # 只缓存真正翻译了的结果
        translation_cache.put(text, result)
    
    return result

def enrich_data_with_chinese_translation(vulnerabilities, sample_size=100):
    """
    使用中文翻译丰富漏洞数据，采用并行处理提高速度
    
    Args:
        vulnerabilities: 漏洞数据列表
        sample_size: 要翻译的样本数量
    
    Returns:
        list: 丰富后的漏洞数据列表
    """
    # 随机选择一部分样本进行翻译，以避免处理过多数据
    if len(vulnerabilities) > sample_size:
        sample_indices = random.sample(range(len(vulnerabilities)), sample_size)
        samples = [vulnerabilities[i] for i in sample_indices]
    else:
        samples = vulnerabilities[:]
    
    logger.info(f"开始为 {len(samples)} 条漏洞数据添加中文翻译")
    
    # 定义一个处理单个漏洞数据的函数
    def process_vulnerability(vuln):
        try:
            # 翻译描述
            if 'description' in vuln and vuln['description']:
                translated_description = cached_translate(vuln.get('description', ''))
                if translated_description and translated_description != vuln.get('description', ''):
                    vuln['description_zh'] = translated_description
            
            # 翻译详情
            if 'details' in vuln and vuln['details']:
                translated_details = cached_translate(vuln.get('details', ''))
                if translated_details and translated_details != vuln.get('details', ''):
                    vuln['details_zh'] = translated_details
            
            return vuln
        except Exception as e:
            logger.error(f"翻译漏洞数据时出错: {str(e)}")
            return vuln
    
    # 使用ThreadPoolExecutor并行处理翻译任务
    with ThreadPoolExecutor(max_workers=min(10, os.cpu_count() * 2)) as executor:
        # 提交所有任务
        future_to_index = {executor.submit(process_vulnerability, vuln): i for i, vuln in enumerate(samples)}
        
        # 使用tqdm显示进度
        for future in tqdm(concurrent.futures.as_completed(future_to_index), total=len(samples), desc="翻译漏洞数据"):
            index = future_to_index[future]
            try:
                samples[index] = future.result()
            except Exception as e:
                logger.error(f"处理翻译任务结果时出错: {str(e)}")
    
    # 保存翻译缓存
    translation_cache.save_cache()
    
    logger.info(f"完成 {len(samples)} 条漏洞数据的中文翻译")
    return vulnerabilities

def process_nvd_vulnerabilities():
    """
    处理NVD漏洞数据
    
    Returns:
        list: 处理后的NVD漏洞数据
    """
    # 获取最近10年的NVD数据
    current_year = datetime.now().year
    nvd_vulnerabilities = fetch_nvd_data((current_year - 10, current_year))
    
    # 丰富数据
    return nvd_vulnerabilities

def process_cve_vulnerabilities():
    """
    处理CVE漏洞数据
    
    Returns:
        list: 处理后的CVE漏洞数据
    """
    # 获取CVE MITRE数据
    cve_vulnerabilities = fetch_cve_mitre_data()
    
    # 丰富数据
    return cve_vulnerabilities

def process_cnnvd_vulnerabilities():
    """
    处理CNNVD漏洞数据（模拟）
    
    Returns:
        list: 处理后的CNNVD漏洞数据
    """
    # 由于无法直接访问CNNVD数据，这里创建一些中文漏洞数据作为示例
    cnnvd_vulnerabilities = []
    
    # 模拟数据
    for i in range(1000):
        vuln_id = f"CNNVD-{(datetime.now().year - random.randint(0, 5)):04d}{random.randint(1, 12):02d}-{random.randint(1, 9999):04d}"
        risk_levels = ["高危", "中危", "低危"]
        vuln_types = ["缓冲区溢出", "跨站脚本", "SQL注入", "权限提升", "拒绝服务", "信息泄露", "命令注入"]
        
        vulnerability = {
            'id': vuln_id,
            'risk_level': random.choice(risk_levels),
            'type': random.choice(vuln_types),
            'function': f"function_{vuln_id.lower().replace('-', '_')}",
            'description': f"这是一个{random.choice(risk_levels)}级别的{random.choice(vuln_types)}漏洞，可能导致系统不稳定或安全问题。",
            'details': f"攻击者可能通过特定的输入触发此漏洞，导致系统出现异常行为。受影响的组件在处理特定输入时没有进行充分的验证和过滤。",
            'affected_versions': f"受影响的版本包括 v1.0-v{random.randint(1, 5)}.{random.randint(0, 9)}",
            'cve_reference': "",
            'discovered_date': f"{(datetime.now().year - random.randint(0, 5)):04d}-{random.randint(1, 12):02d}-{random.randint(1, 28):02d}",
            'source': 'CNNVD模拟数据'
        }
        
        cnnvd_vulnerabilities.append(vulnerability)
    
    return cnnvd_vulnerabilities

def save_vulnerabilities(vulnerabilities, output_file=OUTPUT_FILE):
    """
    保存漏洞数据到JSON文件
    
    Args:
        vulnerabilities: 漏洞数据列表
        output_file: 输出文件路径
    """
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump({"vulnerabilities": vulnerabilities}, f, ensure_ascii=False, indent=2)
        logger.info(f"成功保存 {len(vulnerabilities)} 条漏洞数据到 {output_file}")
    except Exception as e:
        logger.error(f"保存漏洞数据时出错: {str(e)}")

def merge_vulnerabilities(nvd_data, cve_data, cnnvd_data):
    """
    合并来自不同来源的漏洞数据，去除重复项
    
    Args:
        nvd_data: NVD漏洞数据
        cve_data: CVE漏洞数据
        cnnvd_data: CNNVD漏洞数据
    
    Returns:
        list: 合并后的漏洞数据
    """
    all_data = nvd_data + cnnvd_data
    
    # 使用CVE数据补充NVD中没有的漏洞
    nvd_cve_ids = set(vuln['id'] for vuln in nvd_data)
    for vuln in cve_data:
        if vuln['id'] not in nvd_cve_ids:
            all_data.append(vuln)
    
    logger.info(f"合并后共有 {len(all_data)} 条漏洞数据")
    return all_data

def main():
    """主函数"""
    logger.info("开始获取漏洞数据")
    
    # 处理各数据源的漏洞数据，不包括NVD
    with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
        cve_future = executor.submit(process_cve_vulnerabilities)
        cnnvd_future = executor.submit(process_cnnvd_vulnerabilities)
        
        cve_vulnerabilities = cve_future.result()
        cnnvd_vulnerabilities = cnnvd_future.result()
    
    # 合并数据源的漏洞数据，不包括NVD
    merged_vulnerabilities = cve_vulnerabilities + cnnvd_vulnerabilities
    logger.info(f"合并后共有 {len(merged_vulnerabilities)} 条漏洞数据")
    
    # 丰富部分数据的中文翻译
    enriched_vulnerabilities = enrich_data_with_chinese_translation(merged_vulnerabilities)
    
    # 保存数据到JSON文件
    save_vulnerabilities(enriched_vulnerabilities)
    
    logger.info("漏洞数据获取完成")

if __name__ == "__main__":
    main() 